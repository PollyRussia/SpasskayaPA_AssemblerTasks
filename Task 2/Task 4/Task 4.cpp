// Task 4.cpp: определяет точку входа для консольного приложения.
#include "stdafx.h"
#include <iostream>
#include <string>
using namespace std;

// функция вывода массива в нормальное число
void print(const char* arr1)
{
	//cout << "\n";
	int i = strlen(arr1) - 1;
	while (arr1[i] <= '0' && i > 0)
		i--;
	for (i = i; i >= 0; i--)
		cout << arr1[i];
	cout << "\n";
}

int main()
{
	// ПЕРЕМЕННЫЕ
	string s1, s2;
	// объявляются 11 разрядов, а исп-ся 10 потому что код последнего разрада 0, а не 48, даже если значение "0" 
	// поэтому при  arr1[10] возникают проблемы сравнения последнего разряда с "0", а так он просто не изменяется
	char arr1[11] = "0000000000"; // массив для 1 числа
	char arr2[11] = "0000000000"; // массив для 2 числа
	char arr3[12] = "00000000000"; // результат сложения
	char arr4[12] = "00000000000"; //результат вычитания
	int result = 1; // результат сравнения
	const char* arr0; // вспомогательный массив для преобразования строки в перевернутый массив

	setlocale(LC_ALL, "RUS"); // чтобы русские буковки выводились
	cout << "Задачи 4, 5, 6" << "\n";
	cout << "Пользователь вводит два числа и получает их сумму, разность и результат сравнения" << "\n";
	cout << "Разность вычисляется, только если первое число не меньше второго" << "\n";
	
	// ВВОД
	cout << "Введите первое число (до 10 разрядов)" << "\n";
	getline(cin, s1); // чтение 1-го числа (строки)
	arr0 = s1.data();
	for (int i = strlen(arr0) - 1; i >= 0; i--) // приведение 1-го числа
		arr1[i] = arr0[strlen(arr0) - 1 - i];
	cout << "Введите второе число (до 10 разрядов)" << "\n";
	getline(cin, s2);arr0 = s2.data(); // чтение 2-го числа
	for (int i = strlen(arr0) - 1; i >= 0; i--) // приведение 2-го числа
		arr2[i] = arr0[strlen(arr0) - 1 - i];
	

	// ВЫЧИСЛЕНИЕ СУММЫ чисел при помощи длинной арифметики
	_asm
	{
		mov ESI, 0 //обнуление счетчика
	prime0:
		xor edx, edx
		mov dl, arr1[ESI] // разряд 1-го числа
		add dl, arr2[ESI] // разряд 2-го числа
		add dl, arr3[ESI] // переполнение предыдущего разряда (если было, то текущий '1', иначе '0')
		sub edx, '0'*3 // получение цифры
		cmp edx, 9 // проверка на переполнение
		jbe prime1 // если переполнения нет - переход
		// переполнение разряда
		sub edx, 10 // убираем переполнение
		mov arr3[ESI + 1], 1 + '0' //добавление старшего разряда (+1)
	prime1: // запись цифры в текущий разряд
		add edx, '0' // преобразуем в символ
		mov arr3[ESI], dl // добавление разряда в массив вывода
		inc ESI // увеличение счетика
		cmp ESI, 9 // проверка на выход из циклка (счетчик > 9)
		jbe prime0 // иначе продолжаем
	}


	// ВЫЧИСЛЕНИЕ РАЗНОСТИ чисел при помощи длинной арифметики
	// !!!! первое число >= второго !!!!!
	_asm
	{
		mov ESI, 0 //обнуление счетчика
	prime00:
		xor edx, edx
		mov dl, arr1[ESI] // разряд 1-го числа
		sub dl, arr2[ESI] // разряд 2-го числа
		add dl, arr4[ESI] // "заем" у предыдущего разряда
		cmp edx, '0' // проверка на недостаток
		jae prime11 // если все ОК - переход
		// иначе беpем 1 из старшего разряда
		add edx, 10
		mov arr4[ESI + 1], '0' - 1 //уменьшение старшего разряда (-1)
	prime11: // запись цифры в текущий разряд
		mov arr4[ESI], dl // добавление разряда в массив вывода
		inc ESI // увеличение счетика
		cmp ESI, 9 // проверка на выход из циклка (счетчик > 9)
		jbe prime00 // иначе продолжаем
	}


	// СРАВНЕНИЕ чисел при помощи длинной арифметики
	// Результат – 0, если значения совпали; –1, если первое число меньше второго; 1, если первое число больше второго.
	_asm
	{
		// изначально полагаем первое число большими
		mov ESI, 10 // определение счетчика - читаем массивы с конца
		xor ebx, ebx
	prime000: 
		//начало цикла
		dec ESI // уменьшение счетчика
		xor edx, edx
		add edx, '0'
		add dl, arr1[ESI] // разряд 1-го числа
		sub dl, arr2[ESI] // разряд 2-го числа
		cmp edx, '0' // сравниваем с '0'
		jb prime111 // edx < '0', если разряд 2-го числа больше -> 2-е число больше, переход
		je prime444 // edx == '0' -> цифры разряда совпадают -> продолжаем
		jne prime333
	prime444: 
		cmp ESI, 0 // достигли начала массивов?
		jne prime000 // нет - продолжаем сравнение
		je prime222 // иначе переход
		// конец цикла
	prime111: // когда число 2-е число больше
		mov result, -1 // записываем результат
	prime222:
		cmp edx, '0' // edx == '0' -> цифры всех разрядов совпадают -> числа равны
		jne prime333 // иначе результат уже заполнен
		mov result, 0
	prime333:
	}
	//ВЫВОД
	cout << "\n";
	cout << "Сумма чисел:" << "\n";
	print(arr3);
	cout << "Разность чисел:" << "\n";
	if (result == -1)
		cout << "Не может быть вычислена. Т. к. второе число большн первого." << "\n";
	else
		print(arr4);
	cout << "Сравнение: " << result;
	cout << "\n";
	cout << "Результат сравнения – 0, если значения совпали; –1, если первое число меньше второго; 1, если первое число больше второго." << "\n";
	cout << "\n";
	
	return 0;
}

